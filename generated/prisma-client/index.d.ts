// Code generated by Prisma (prisma@1.28.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  bodyMeasurement: (where?: BodyMeasurementWhereInput) => Promise<boolean>;
  bodyMetric: (where?: BodyMetricWhereInput) => Promise<boolean>;
  exercise: (where?: ExerciseWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  savedWorkout: (where?: SavedWorkoutWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  workout: (where?: WorkoutWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bodyMeasurement: (
    where: BodyMeasurementWhereUniqueInput
  ) => BodyMeasurementPromise;
  bodyMeasurements: (
    args?: {
      where?: BodyMeasurementWhereInput;
      orderBy?: BodyMeasurementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BodyMeasurement>;
  bodyMeasurementsConnection: (
    args?: {
      where?: BodyMeasurementWhereInput;
      orderBy?: BodyMeasurementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BodyMeasurementConnectionPromise;
  bodyMetric: (where: BodyMetricWhereUniqueInput) => BodyMetricPromise;
  bodyMetrics: (
    args?: {
      where?: BodyMetricWhereInput;
      orderBy?: BodyMetricOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BodyMetric>;
  bodyMetricsConnection: (
    args?: {
      where?: BodyMetricWhereInput;
      orderBy?: BodyMetricOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BodyMetricConnectionPromise;
  exercise: (where: ExerciseWhereUniqueInput) => ExercisePromise;
  exercises: (
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Exercise>;
  exercisesConnection: (
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExerciseConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NotePromise;
  notes: (
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Note>;
  notesConnection: (
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NoteConnectionPromise;
  savedWorkout: (where: SavedWorkoutWhereUniqueInput) => SavedWorkoutPromise;
  savedWorkouts: (
    args?: {
      where?: SavedWorkoutWhereInput;
      orderBy?: SavedWorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SavedWorkout>;
  savedWorkoutsConnection: (
    args?: {
      where?: SavedWorkoutWhereInput;
      orderBy?: SavedWorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SavedWorkoutConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  schedules: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Schedule>;
  schedulesConnection: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  workout: (where: WorkoutWhereUniqueInput) => WorkoutPromise;
  workouts: (
    args?: {
      where?: WorkoutWhereInput;
      orderBy?: WorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Workout>;
  workoutsConnection: (
    args?: {
      where?: WorkoutWhereInput;
      orderBy?: WorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkoutConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBodyMeasurement: (
    data: BodyMeasurementCreateInput
  ) => BodyMeasurementPromise;
  updateBodyMeasurement: (
    args: {
      data: BodyMeasurementUpdateInput;
      where: BodyMeasurementWhereUniqueInput;
    }
  ) => BodyMeasurementPromise;
  updateManyBodyMeasurements: (
    args: {
      data: BodyMeasurementUpdateManyMutationInput;
      where?: BodyMeasurementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBodyMeasurement: (
    args: {
      where: BodyMeasurementWhereUniqueInput;
      create: BodyMeasurementCreateInput;
      update: BodyMeasurementUpdateInput;
    }
  ) => BodyMeasurementPromise;
  deleteBodyMeasurement: (
    where: BodyMeasurementWhereUniqueInput
  ) => BodyMeasurementPromise;
  deleteManyBodyMeasurements: (
    where?: BodyMeasurementWhereInput
  ) => BatchPayloadPromise;
  createBodyMetric: (data: BodyMetricCreateInput) => BodyMetricPromise;
  updateBodyMetric: (
    args: { data: BodyMetricUpdateInput; where: BodyMetricWhereUniqueInput }
  ) => BodyMetricPromise;
  updateManyBodyMetrics: (
    args: {
      data: BodyMetricUpdateManyMutationInput;
      where?: BodyMetricWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBodyMetric: (
    args: {
      where: BodyMetricWhereUniqueInput;
      create: BodyMetricCreateInput;
      update: BodyMetricUpdateInput;
    }
  ) => BodyMetricPromise;
  deleteBodyMetric: (where: BodyMetricWhereUniqueInput) => BodyMetricPromise;
  deleteManyBodyMetrics: (where?: BodyMetricWhereInput) => BatchPayloadPromise;
  createExercise: (data: ExerciseCreateInput) => ExercisePromise;
  updateExercise: (
    args: { data: ExerciseUpdateInput; where: ExerciseWhereUniqueInput }
  ) => ExercisePromise;
  updateManyExercises: (
    args: { data: ExerciseUpdateManyMutationInput; where?: ExerciseWhereInput }
  ) => BatchPayloadPromise;
  upsertExercise: (
    args: {
      where: ExerciseWhereUniqueInput;
      create: ExerciseCreateInput;
      update: ExerciseUpdateInput;
    }
  ) => ExercisePromise;
  deleteExercise: (where: ExerciseWhereUniqueInput) => ExercisePromise;
  deleteManyExercises: (where?: ExerciseWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (
    args: { data: NoteUpdateInput; where: NoteWhereUniqueInput }
  ) => NotePromise;
  updateManyNotes: (
    args: { data: NoteUpdateManyMutationInput; where?: NoteWhereInput }
  ) => BatchPayloadPromise;
  upsertNote: (
    args: {
      where: NoteWhereUniqueInput;
      create: NoteCreateInput;
      update: NoteUpdateInput;
    }
  ) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createSavedWorkout: (data: SavedWorkoutCreateInput) => SavedWorkoutPromise;
  updateSavedWorkout: (
    args: { data: SavedWorkoutUpdateInput; where: SavedWorkoutWhereUniqueInput }
  ) => SavedWorkoutPromise;
  updateManySavedWorkouts: (
    args: {
      data: SavedWorkoutUpdateManyMutationInput;
      where?: SavedWorkoutWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSavedWorkout: (
    args: {
      where: SavedWorkoutWhereUniqueInput;
      create: SavedWorkoutCreateInput;
      update: SavedWorkoutUpdateInput;
    }
  ) => SavedWorkoutPromise;
  deleteSavedWorkout: (
    where: SavedWorkoutWhereUniqueInput
  ) => SavedWorkoutPromise;
  deleteManySavedWorkouts: (
    where?: SavedWorkoutWhereInput
  ) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (
    args: { data: ScheduleUpdateInput; where: ScheduleWhereUniqueInput }
  ) => SchedulePromise;
  updateManySchedules: (
    args: { data: ScheduleUpdateManyMutationInput; where?: ScheduleWhereInput }
  ) => BatchPayloadPromise;
  upsertSchedule: (
    args: {
      where: ScheduleWhereUniqueInput;
      create: ScheduleCreateInput;
      update: ScheduleUpdateInput;
    }
  ) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWorkout: (data: WorkoutCreateInput) => WorkoutPromise;
  updateWorkout: (
    args: { data: WorkoutUpdateInput; where: WorkoutWhereUniqueInput }
  ) => WorkoutPromise;
  updateManyWorkouts: (
    args: { data: WorkoutUpdateManyMutationInput; where?: WorkoutWhereInput }
  ) => BatchPayloadPromise;
  upsertWorkout: (
    args: {
      where: WorkoutWhereUniqueInput;
      create: WorkoutCreateInput;
      update: WorkoutUpdateInput;
    }
  ) => WorkoutPromise;
  deleteWorkout: (where: WorkoutWhereUniqueInput) => WorkoutPromise;
  deleteManyWorkouts: (where?: WorkoutWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bodyMeasurement: (
    where?: BodyMeasurementSubscriptionWhereInput
  ) => BodyMeasurementSubscriptionPayloadSubscription;
  bodyMetric: (
    where?: BodyMetricSubscriptionWhereInput
  ) => BodyMetricSubscriptionPayloadSubscription;
  exercise: (
    where?: ExerciseSubscriptionWhereInput
  ) => ExerciseSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  savedWorkout: (
    where?: SavedWorkoutSubscriptionWhereInput
  ) => SavedWorkoutSubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  workout: (
    where?: WorkoutSubscriptionWhereInput
  ) => WorkoutSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "time_ASC"
  | "time_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WorkoutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExerciseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "sets_ASC"
  | "sets_DESC"
  | "reps_ASC"
  | "reps_DESC"
  | "intervals_ASC"
  | "intervals_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "intensity_ASC"
  | "intensity_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SavedWorkoutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BodyMetricOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "height_ASC"
  | "height_DESC"
  | "bodyfat_ASC"
  | "bodyfat_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BodyMeasurementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hips_ASC"
  | "hips_DESC"
  | "waist_ASC"
  | "waist_DESC"
  | "rightArm_ASC"
  | "rightArm_DESC"
  | "leftArm_ASC"
  | "leftArm_DESC"
  | "rightLeg_ASC"
  | "rightLeg_DESC"
  | "leftLeg_ASC"
  | "leftLeg_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "authId_ASC"
  | "authId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BodyMeasurementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  workouts_every?: WorkoutWhereInput;
  workouts_some?: WorkoutWhereInput;
  workouts_none?: WorkoutWhereInput;
  completed?: Boolean;
  completed_not?: Boolean;
  user?: UserWhereInput;
  AND?: ScheduleWhereInput[] | ScheduleWhereInput;
  OR?: ScheduleWhereInput[] | ScheduleWhereInput;
  NOT?: ScheduleWhereInput[] | ScheduleWhereInput;
}

export interface WorkoutWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  exercises_every?: ExerciseWhereInput;
  exercises_some?: ExerciseWhereInput;
  exercises_none?: ExerciseWhereInput;
  completed?: Boolean;
  completed_not?: Boolean;
  schedule?: ScheduleWhereInput;
  AND?: WorkoutWhereInput[] | WorkoutWhereInput;
  OR?: WorkoutWhereInput[] | WorkoutWhereInput;
  NOT?: WorkoutWhereInput[] | WorkoutWhereInput;
}

export interface ExerciseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  sets?: Int;
  sets_not?: Int;
  sets_in?: Int[] | Int;
  sets_not_in?: Int[] | Int;
  sets_lt?: Int;
  sets_lte?: Int;
  sets_gt?: Int;
  sets_gte?: Int;
  reps?: Int;
  reps_not?: Int;
  reps_in?: Int[] | Int;
  reps_not_in?: Int[] | Int;
  reps_lt?: Int;
  reps_lte?: Int;
  reps_gt?: Int;
  reps_gte?: Int;
  intervals?: Int;
  intervals_not?: Int;
  intervals_in?: Int[] | Int;
  intervals_not_in?: Int[] | Int;
  intervals_lt?: Int;
  intervals_lte?: Int;
  intervals_gt?: Int;
  intervals_gte?: Int;
  duration?: Float;
  duration_not?: Float;
  duration_in?: Float[] | Float;
  duration_not_in?: Float[] | Float;
  duration_lt?: Float;
  duration_lte?: Float;
  duration_gt?: Float;
  duration_gte?: Float;
  intensity?: Int;
  intensity_not?: Int;
  intensity_in?: Int[] | Int;
  intensity_not_in?: Int[] | Int;
  intensity_lt?: Int;
  intensity_lte?: Int;
  intensity_gt?: Int;
  intensity_gte?: Int;
  completed?: Boolean;
  completed_not?: Boolean;
  workout?: WorkoutWhereInput;
  savedWorkout?: SavedWorkoutWhereInput;
  AND?: ExerciseWhereInput[] | ExerciseWhereInput;
  OR?: ExerciseWhereInput[] | ExerciseWhereInput;
  NOT?: ExerciseWhereInput[] | ExerciseWhereInput;
}

export interface SavedWorkoutWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  exercises_every?: ExerciseWhereInput;
  exercises_some?: ExerciseWhereInput;
  exercises_none?: ExerciseWhereInput;
  user?: UserWhereInput;
  AND?: SavedWorkoutWhereInput[] | SavedWorkoutWhereInput;
  OR?: SavedWorkoutWhereInput[] | SavedWorkoutWhereInput;
  NOT?: SavedWorkoutWhereInput[] | SavedWorkoutWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  schedules_every?: ScheduleWhereInput;
  schedules_some?: ScheduleWhereInput;
  schedules_none?: ScheduleWhereInput;
  savedWorkouts_every?: SavedWorkoutWhereInput;
  savedWorkouts_some?: SavedWorkoutWhereInput;
  savedWorkouts_none?: SavedWorkoutWhereInput;
  notes_every?: NoteWhereInput;
  notes_some?: NoteWhereInput;
  notes_none?: NoteWhereInput;
  bodyMetrics_every?: BodyMetricWhereInput;
  bodyMetrics_some?: BodyMetricWhereInput;
  bodyMetrics_none?: BodyMetricWhereInput;
  bodyMeasurements_every?: BodyMeasurementWhereInput;
  bodyMeasurements_some?: BodyMeasurementWhereInput;
  bodyMeasurements_none?: BodyMeasurementWhereInput;
  authId?: String;
  authId_not?: String;
  authId_in?: String[] | String;
  authId_not_in?: String[] | String;
  authId_lt?: String;
  authId_lte?: String;
  authId_gt?: String;
  authId_gte?: String;
  authId_contains?: String;
  authId_not_contains?: String;
  authId_starts_with?: String;
  authId_not_starts_with?: String;
  authId_ends_with?: String;
  authId_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface NoteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  note?: String;
  note_not?: String;
  note_in?: String[] | String;
  note_not_in?: String[] | String;
  note_lt?: String;
  note_lte?: String;
  note_gt?: String;
  note_gte?: String;
  note_contains?: String;
  note_not_contains?: String;
  note_starts_with?: String;
  note_not_starts_with?: String;
  note_ends_with?: String;
  note_not_ends_with?: String;
  workout?: WorkoutWhereInput;
  createdBy?: UserWhereInput;
  schedule?: ScheduleWhereInput;
  AND?: NoteWhereInput[] | NoteWhereInput;
  OR?: NoteWhereInput[] | NoteWhereInput;
  NOT?: NoteWhereInput[] | NoteWhereInput;
}

export interface BodyMetricWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weight?: Float;
  weight_not?: Float;
  weight_in?: Float[] | Float;
  weight_not_in?: Float[] | Float;
  weight_lt?: Float;
  weight_lte?: Float;
  weight_gt?: Float;
  weight_gte?: Float;
  height?: Float;
  height_not?: Float;
  height_in?: Float[] | Float;
  height_not_in?: Float[] | Float;
  height_lt?: Float;
  height_lte?: Float;
  height_gt?: Float;
  height_gte?: Float;
  bodyfat?: Float;
  bodyfat_not?: Float;
  bodyfat_in?: Float[] | Float;
  bodyfat_not_in?: Float[] | Float;
  bodyfat_lt?: Float;
  bodyfat_lte?: Float;
  bodyfat_gt?: Float;
  bodyfat_gte?: Float;
  user?: UserWhereInput;
  AND?: BodyMetricWhereInput[] | BodyMetricWhereInput;
  OR?: BodyMetricWhereInput[] | BodyMetricWhereInput;
  NOT?: BodyMetricWhereInput[] | BodyMetricWhereInput;
}

export interface BodyMeasurementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  hips?: Float;
  hips_not?: Float;
  hips_in?: Float[] | Float;
  hips_not_in?: Float[] | Float;
  hips_lt?: Float;
  hips_lte?: Float;
  hips_gt?: Float;
  hips_gte?: Float;
  waist?: Float;
  waist_not?: Float;
  waist_in?: Float[] | Float;
  waist_not_in?: Float[] | Float;
  waist_lt?: Float;
  waist_lte?: Float;
  waist_gt?: Float;
  waist_gte?: Float;
  rightArm?: Float;
  rightArm_not?: Float;
  rightArm_in?: Float[] | Float;
  rightArm_not_in?: Float[] | Float;
  rightArm_lt?: Float;
  rightArm_lte?: Float;
  rightArm_gt?: Float;
  rightArm_gte?: Float;
  leftArm?: Float;
  leftArm_not?: Float;
  leftArm_in?: Float[] | Float;
  leftArm_not_in?: Float[] | Float;
  leftArm_lt?: Float;
  leftArm_lte?: Float;
  leftArm_gt?: Float;
  leftArm_gte?: Float;
  rightLeg?: Float;
  rightLeg_not?: Float;
  rightLeg_in?: Float[] | Float;
  rightLeg_not_in?: Float[] | Float;
  rightLeg_lt?: Float;
  rightLeg_lte?: Float;
  rightLeg_gt?: Float;
  rightLeg_gte?: Float;
  leftLeg?: Float;
  leftLeg_not?: Float;
  leftLeg_in?: Float[] | Float;
  leftLeg_not_in?: Float[] | Float;
  leftLeg_lt?: Float;
  leftLeg_lte?: Float;
  leftLeg_gt?: Float;
  leftLeg_gte?: Float;
  user?: UserWhereInput;
  AND?: BodyMeasurementWhereInput[] | BodyMeasurementWhereInput;
  OR?: BodyMeasurementWhereInput[] | BodyMeasurementWhereInput;
  NOT?: BodyMeasurementWhereInput[] | BodyMeasurementWhereInput;
}

export type BodyMetricWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ExerciseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type NoteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SavedWorkoutWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  authId?: String;
}>;

export type WorkoutWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BodyMeasurementCreateInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
  user: UserCreateOneWithoutBodyMeasurementsInput;
}

export interface UserCreateOneWithoutBodyMeasurementsInput {
  create?: UserCreateWithoutBodyMeasurementsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutBodyMeasurementsInput {
  schedules?: ScheduleCreateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutCreateManyWithoutUserInput;
  notes?: NoteCreateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricCreateManyWithoutUserInput;
  authId: String;
}

export interface ScheduleCreateManyWithoutUserInput {
  create?: ScheduleCreateWithoutUserInput[] | ScheduleCreateWithoutUserInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
}

export interface ScheduleCreateWithoutUserInput {
  time: String;
  workouts?: WorkoutCreateManyWithoutScheduleInput;
  completed?: Boolean;
}

export interface WorkoutCreateManyWithoutScheduleInput {
  create?:
    | WorkoutCreateWithoutScheduleInput[]
    | WorkoutCreateWithoutScheduleInput;
  connect?: WorkoutWhereUniqueInput[] | WorkoutWhereUniqueInput;
}

export interface WorkoutCreateWithoutScheduleInput {
  name: String;
  exercises?: ExerciseCreateManyWithoutWorkoutInput;
  completed?: Boolean;
}

export interface ExerciseCreateManyWithoutWorkoutInput {
  create?:
    | ExerciseCreateWithoutWorkoutInput[]
    | ExerciseCreateWithoutWorkoutInput;
  connect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
}

export interface ExerciseCreateWithoutWorkoutInput {
  name: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  savedWorkout?: SavedWorkoutCreateOneWithoutExercisesInput;
}

export interface SavedWorkoutCreateOneWithoutExercisesInput {
  create?: SavedWorkoutCreateWithoutExercisesInput;
  connect?: SavedWorkoutWhereUniqueInput;
}

export interface SavedWorkoutCreateWithoutExercisesInput {
  name: String;
  user: UserCreateOneWithoutSavedWorkoutsInput;
}

export interface UserCreateOneWithoutSavedWorkoutsInput {
  create?: UserCreateWithoutSavedWorkoutsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutSavedWorkoutsInput {
  schedules?: ScheduleCreateManyWithoutUserInput;
  notes?: NoteCreateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricCreateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementCreateManyWithoutUserInput;
  authId: String;
}

export interface NoteCreateManyWithoutCreatedByInput {
  create?: NoteCreateWithoutCreatedByInput[] | NoteCreateWithoutCreatedByInput;
  connect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
}

export interface NoteCreateWithoutCreatedByInput {
  note: String;
  workout?: WorkoutCreateOneInput;
  schedule?: ScheduleCreateOneInput;
}

export interface WorkoutCreateOneInput {
  create?: WorkoutCreateInput;
  connect?: WorkoutWhereUniqueInput;
}

export interface WorkoutCreateInput {
  name: String;
  exercises?: ExerciseCreateManyWithoutWorkoutInput;
  completed?: Boolean;
  schedule: ScheduleCreateOneWithoutWorkoutsInput;
}

export interface ScheduleCreateOneWithoutWorkoutsInput {
  create?: ScheduleCreateWithoutWorkoutsInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleCreateWithoutWorkoutsInput {
  time: String;
  completed?: Boolean;
  user: UserCreateOneWithoutSchedulesInput;
}

export interface UserCreateOneWithoutSchedulesInput {
  create?: UserCreateWithoutSchedulesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutSchedulesInput {
  savedWorkouts?: SavedWorkoutCreateManyWithoutUserInput;
  notes?: NoteCreateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricCreateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementCreateManyWithoutUserInput;
  authId: String;
}

export interface SavedWorkoutCreateManyWithoutUserInput {
  create?:
    | SavedWorkoutCreateWithoutUserInput[]
    | SavedWorkoutCreateWithoutUserInput;
  connect?: SavedWorkoutWhereUniqueInput[] | SavedWorkoutWhereUniqueInput;
}

export interface SavedWorkoutCreateWithoutUserInput {
  name: String;
  exercises?: ExerciseCreateManyWithoutSavedWorkoutInput;
}

export interface ExerciseCreateManyWithoutSavedWorkoutInput {
  create?:
    | ExerciseCreateWithoutSavedWorkoutInput[]
    | ExerciseCreateWithoutSavedWorkoutInput;
  connect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
}

export interface ExerciseCreateWithoutSavedWorkoutInput {
  name: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  workout?: WorkoutCreateOneWithoutExercisesInput;
}

export interface WorkoutCreateOneWithoutExercisesInput {
  create?: WorkoutCreateWithoutExercisesInput;
  connect?: WorkoutWhereUniqueInput;
}

export interface WorkoutCreateWithoutExercisesInput {
  name: String;
  completed?: Boolean;
  schedule: ScheduleCreateOneWithoutWorkoutsInput;
}

export interface BodyMetricCreateManyWithoutUserInput {
  create?:
    | BodyMetricCreateWithoutUserInput[]
    | BodyMetricCreateWithoutUserInput;
  connect?: BodyMetricWhereUniqueInput[] | BodyMetricWhereUniqueInput;
}

export interface BodyMetricCreateWithoutUserInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface BodyMeasurementCreateManyWithoutUserInput {
  create?:
    | BodyMeasurementCreateWithoutUserInput[]
    | BodyMeasurementCreateWithoutUserInput;
  connect?: BodyMeasurementWhereUniqueInput[] | BodyMeasurementWhereUniqueInput;
}

export interface BodyMeasurementCreateWithoutUserInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface ScheduleCreateOneInput {
  create?: ScheduleCreateInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleCreateInput {
  time: String;
  workouts?: WorkoutCreateManyWithoutScheduleInput;
  completed?: Boolean;
  user: UserCreateOneWithoutSchedulesInput;
}

export interface BodyMeasurementUpdateInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
  user?: UserUpdateOneRequiredWithoutBodyMeasurementsInput;
}

export interface UserUpdateOneRequiredWithoutBodyMeasurementsInput {
  create?: UserCreateWithoutBodyMeasurementsInput;
  update?: UserUpdateWithoutBodyMeasurementsDataInput;
  upsert?: UserUpsertWithoutBodyMeasurementsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutBodyMeasurementsDataInput {
  schedules?: ScheduleUpdateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutUpdateManyWithoutUserInput;
  notes?: NoteUpdateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricUpdateManyWithoutUserInput;
  authId?: String;
}

export interface ScheduleUpdateManyWithoutUserInput {
  create?: ScheduleCreateWithoutUserInput[] | ScheduleCreateWithoutUserInput;
  delete?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  set?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  disconnect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  update?:
    | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    | ScheduleUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    | ScheduleUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ScheduleScalarWhereInput[] | ScheduleScalarWhereInput;
  updateMany?:
    | ScheduleUpdateManyWithWhereNestedInput[]
    | ScheduleUpdateManyWithWhereNestedInput;
}

export interface ScheduleUpdateWithWhereUniqueWithoutUserInput {
  where: ScheduleWhereUniqueInput;
  data: ScheduleUpdateWithoutUserDataInput;
}

export interface ScheduleUpdateWithoutUserDataInput {
  time?: String;
  workouts?: WorkoutUpdateManyWithoutScheduleInput;
  completed?: Boolean;
}

export interface WorkoutUpdateManyWithoutScheduleInput {
  create?:
    | WorkoutCreateWithoutScheduleInput[]
    | WorkoutCreateWithoutScheduleInput;
  delete?: WorkoutWhereUniqueInput[] | WorkoutWhereUniqueInput;
  connect?: WorkoutWhereUniqueInput[] | WorkoutWhereUniqueInput;
  set?: WorkoutWhereUniqueInput[] | WorkoutWhereUniqueInput;
  disconnect?: WorkoutWhereUniqueInput[] | WorkoutWhereUniqueInput;
  update?:
    | WorkoutUpdateWithWhereUniqueWithoutScheduleInput[]
    | WorkoutUpdateWithWhereUniqueWithoutScheduleInput;
  upsert?:
    | WorkoutUpsertWithWhereUniqueWithoutScheduleInput[]
    | WorkoutUpsertWithWhereUniqueWithoutScheduleInput;
  deleteMany?: WorkoutScalarWhereInput[] | WorkoutScalarWhereInput;
  updateMany?:
    | WorkoutUpdateManyWithWhereNestedInput[]
    | WorkoutUpdateManyWithWhereNestedInput;
}

export interface WorkoutUpdateWithWhereUniqueWithoutScheduleInput {
  where: WorkoutWhereUniqueInput;
  data: WorkoutUpdateWithoutScheduleDataInput;
}

export interface WorkoutUpdateWithoutScheduleDataInput {
  name?: String;
  exercises?: ExerciseUpdateManyWithoutWorkoutInput;
  completed?: Boolean;
}

export interface ExerciseUpdateManyWithoutWorkoutInput {
  create?:
    | ExerciseCreateWithoutWorkoutInput[]
    | ExerciseCreateWithoutWorkoutInput;
  delete?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  connect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  set?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  disconnect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  update?:
    | ExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    | ExerciseUpdateWithWhereUniqueWithoutWorkoutInput;
  upsert?:
    | ExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    | ExerciseUpsertWithWhereUniqueWithoutWorkoutInput;
  deleteMany?: ExerciseScalarWhereInput[] | ExerciseScalarWhereInput;
  updateMany?:
    | ExerciseUpdateManyWithWhereNestedInput[]
    | ExerciseUpdateManyWithWhereNestedInput;
}

export interface ExerciseUpdateWithWhereUniqueWithoutWorkoutInput {
  where: ExerciseWhereUniqueInput;
  data: ExerciseUpdateWithoutWorkoutDataInput;
}

export interface ExerciseUpdateWithoutWorkoutDataInput {
  name?: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  savedWorkout?: SavedWorkoutUpdateOneWithoutExercisesInput;
}

export interface SavedWorkoutUpdateOneWithoutExercisesInput {
  create?: SavedWorkoutCreateWithoutExercisesInput;
  update?: SavedWorkoutUpdateWithoutExercisesDataInput;
  upsert?: SavedWorkoutUpsertWithoutExercisesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SavedWorkoutWhereUniqueInput;
}

export interface SavedWorkoutUpdateWithoutExercisesDataInput {
  name?: String;
  user?: UserUpdateOneRequiredWithoutSavedWorkoutsInput;
}

export interface UserUpdateOneRequiredWithoutSavedWorkoutsInput {
  create?: UserCreateWithoutSavedWorkoutsInput;
  update?: UserUpdateWithoutSavedWorkoutsDataInput;
  upsert?: UserUpsertWithoutSavedWorkoutsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutSavedWorkoutsDataInput {
  schedules?: ScheduleUpdateManyWithoutUserInput;
  notes?: NoteUpdateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricUpdateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementUpdateManyWithoutUserInput;
  authId?: String;
}

export interface NoteUpdateManyWithoutCreatedByInput {
  create?: NoteCreateWithoutCreatedByInput[] | NoteCreateWithoutCreatedByInput;
  delete?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  connect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  set?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  disconnect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  update?:
    | NoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    | NoteUpdateWithWhereUniqueWithoutCreatedByInput;
  upsert?:
    | NoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    | NoteUpsertWithWhereUniqueWithoutCreatedByInput;
  deleteMany?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  updateMany?:
    | NoteUpdateManyWithWhereNestedInput[]
    | NoteUpdateManyWithWhereNestedInput;
}

export interface NoteUpdateWithWhereUniqueWithoutCreatedByInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutCreatedByDataInput;
}

export interface NoteUpdateWithoutCreatedByDataInput {
  note?: String;
  workout?: WorkoutUpdateOneInput;
  schedule?: ScheduleUpdateOneInput;
}

export interface WorkoutUpdateOneInput {
  create?: WorkoutCreateInput;
  update?: WorkoutUpdateDataInput;
  upsert?: WorkoutUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkoutWhereUniqueInput;
}

export interface WorkoutUpdateDataInput {
  name?: String;
  exercises?: ExerciseUpdateManyWithoutWorkoutInput;
  completed?: Boolean;
  schedule?: ScheduleUpdateOneRequiredWithoutWorkoutsInput;
}

export interface ScheduleUpdateOneRequiredWithoutWorkoutsInput {
  create?: ScheduleCreateWithoutWorkoutsInput;
  update?: ScheduleUpdateWithoutWorkoutsDataInput;
  upsert?: ScheduleUpsertWithoutWorkoutsInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleUpdateWithoutWorkoutsDataInput {
  time?: String;
  completed?: Boolean;
  user?: UserUpdateOneRequiredWithoutSchedulesInput;
}

export interface UserUpdateOneRequiredWithoutSchedulesInput {
  create?: UserCreateWithoutSchedulesInput;
  update?: UserUpdateWithoutSchedulesDataInput;
  upsert?: UserUpsertWithoutSchedulesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutSchedulesDataInput {
  savedWorkouts?: SavedWorkoutUpdateManyWithoutUserInput;
  notes?: NoteUpdateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricUpdateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementUpdateManyWithoutUserInput;
  authId?: String;
}

export interface SavedWorkoutUpdateManyWithoutUserInput {
  create?:
    | SavedWorkoutCreateWithoutUserInput[]
    | SavedWorkoutCreateWithoutUserInput;
  delete?: SavedWorkoutWhereUniqueInput[] | SavedWorkoutWhereUniqueInput;
  connect?: SavedWorkoutWhereUniqueInput[] | SavedWorkoutWhereUniqueInput;
  set?: SavedWorkoutWhereUniqueInput[] | SavedWorkoutWhereUniqueInput;
  disconnect?: SavedWorkoutWhereUniqueInput[] | SavedWorkoutWhereUniqueInput;
  update?:
    | SavedWorkoutUpdateWithWhereUniqueWithoutUserInput[]
    | SavedWorkoutUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SavedWorkoutUpsertWithWhereUniqueWithoutUserInput[]
    | SavedWorkoutUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: SavedWorkoutScalarWhereInput[] | SavedWorkoutScalarWhereInput;
  updateMany?:
    | SavedWorkoutUpdateManyWithWhereNestedInput[]
    | SavedWorkoutUpdateManyWithWhereNestedInput;
}

export interface SavedWorkoutUpdateWithWhereUniqueWithoutUserInput {
  where: SavedWorkoutWhereUniqueInput;
  data: SavedWorkoutUpdateWithoutUserDataInput;
}

export interface SavedWorkoutUpdateWithoutUserDataInput {
  name?: String;
  exercises?: ExerciseUpdateManyWithoutSavedWorkoutInput;
}

export interface ExerciseUpdateManyWithoutSavedWorkoutInput {
  create?:
    | ExerciseCreateWithoutSavedWorkoutInput[]
    | ExerciseCreateWithoutSavedWorkoutInput;
  delete?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  connect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  set?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  disconnect?: ExerciseWhereUniqueInput[] | ExerciseWhereUniqueInput;
  update?:
    | ExerciseUpdateWithWhereUniqueWithoutSavedWorkoutInput[]
    | ExerciseUpdateWithWhereUniqueWithoutSavedWorkoutInput;
  upsert?:
    | ExerciseUpsertWithWhereUniqueWithoutSavedWorkoutInput[]
    | ExerciseUpsertWithWhereUniqueWithoutSavedWorkoutInput;
  deleteMany?: ExerciseScalarWhereInput[] | ExerciseScalarWhereInput;
  updateMany?:
    | ExerciseUpdateManyWithWhereNestedInput[]
    | ExerciseUpdateManyWithWhereNestedInput;
}

export interface ExerciseUpdateWithWhereUniqueWithoutSavedWorkoutInput {
  where: ExerciseWhereUniqueInput;
  data: ExerciseUpdateWithoutSavedWorkoutDataInput;
}

export interface ExerciseUpdateWithoutSavedWorkoutDataInput {
  name?: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  workout?: WorkoutUpdateOneWithoutExercisesInput;
}

export interface WorkoutUpdateOneWithoutExercisesInput {
  create?: WorkoutCreateWithoutExercisesInput;
  update?: WorkoutUpdateWithoutExercisesDataInput;
  upsert?: WorkoutUpsertWithoutExercisesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkoutWhereUniqueInput;
}

export interface WorkoutUpdateWithoutExercisesDataInput {
  name?: String;
  completed?: Boolean;
  schedule?: ScheduleUpdateOneRequiredWithoutWorkoutsInput;
}

export interface WorkoutUpsertWithoutExercisesInput {
  update: WorkoutUpdateWithoutExercisesDataInput;
  create: WorkoutCreateWithoutExercisesInput;
}

export interface ExerciseUpsertWithWhereUniqueWithoutSavedWorkoutInput {
  where: ExerciseWhereUniqueInput;
  update: ExerciseUpdateWithoutSavedWorkoutDataInput;
  create: ExerciseCreateWithoutSavedWorkoutInput;
}

export interface ExerciseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  sets?: Int;
  sets_not?: Int;
  sets_in?: Int[] | Int;
  sets_not_in?: Int[] | Int;
  sets_lt?: Int;
  sets_lte?: Int;
  sets_gt?: Int;
  sets_gte?: Int;
  reps?: Int;
  reps_not?: Int;
  reps_in?: Int[] | Int;
  reps_not_in?: Int[] | Int;
  reps_lt?: Int;
  reps_lte?: Int;
  reps_gt?: Int;
  reps_gte?: Int;
  intervals?: Int;
  intervals_not?: Int;
  intervals_in?: Int[] | Int;
  intervals_not_in?: Int[] | Int;
  intervals_lt?: Int;
  intervals_lte?: Int;
  intervals_gt?: Int;
  intervals_gte?: Int;
  duration?: Float;
  duration_not?: Float;
  duration_in?: Float[] | Float;
  duration_not_in?: Float[] | Float;
  duration_lt?: Float;
  duration_lte?: Float;
  duration_gt?: Float;
  duration_gte?: Float;
  intensity?: Int;
  intensity_not?: Int;
  intensity_in?: Int[] | Int;
  intensity_not_in?: Int[] | Int;
  intensity_lt?: Int;
  intensity_lte?: Int;
  intensity_gt?: Int;
  intensity_gte?: Int;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: ExerciseScalarWhereInput[] | ExerciseScalarWhereInput;
  OR?: ExerciseScalarWhereInput[] | ExerciseScalarWhereInput;
  NOT?: ExerciseScalarWhereInput[] | ExerciseScalarWhereInput;
}

export interface ExerciseUpdateManyWithWhereNestedInput {
  where: ExerciseScalarWhereInput;
  data: ExerciseUpdateManyDataInput;
}

export interface ExerciseUpdateManyDataInput {
  name?: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
}

export interface SavedWorkoutUpsertWithWhereUniqueWithoutUserInput {
  where: SavedWorkoutWhereUniqueInput;
  update: SavedWorkoutUpdateWithoutUserDataInput;
  create: SavedWorkoutCreateWithoutUserInput;
}

export interface SavedWorkoutScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SavedWorkoutScalarWhereInput[] | SavedWorkoutScalarWhereInput;
  OR?: SavedWorkoutScalarWhereInput[] | SavedWorkoutScalarWhereInput;
  NOT?: SavedWorkoutScalarWhereInput[] | SavedWorkoutScalarWhereInput;
}

export interface SavedWorkoutUpdateManyWithWhereNestedInput {
  where: SavedWorkoutScalarWhereInput;
  data: SavedWorkoutUpdateManyDataInput;
}

export interface SavedWorkoutUpdateManyDataInput {
  name?: String;
}

export interface BodyMetricUpdateManyWithoutUserInput {
  create?:
    | BodyMetricCreateWithoutUserInput[]
    | BodyMetricCreateWithoutUserInput;
  delete?: BodyMetricWhereUniqueInput[] | BodyMetricWhereUniqueInput;
  connect?: BodyMetricWhereUniqueInput[] | BodyMetricWhereUniqueInput;
  set?: BodyMetricWhereUniqueInput[] | BodyMetricWhereUniqueInput;
  disconnect?: BodyMetricWhereUniqueInput[] | BodyMetricWhereUniqueInput;
  update?:
    | BodyMetricUpdateWithWhereUniqueWithoutUserInput[]
    | BodyMetricUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | BodyMetricUpsertWithWhereUniqueWithoutUserInput[]
    | BodyMetricUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: BodyMetricScalarWhereInput[] | BodyMetricScalarWhereInput;
  updateMany?:
    | BodyMetricUpdateManyWithWhereNestedInput[]
    | BodyMetricUpdateManyWithWhereNestedInput;
}

export interface BodyMetricUpdateWithWhereUniqueWithoutUserInput {
  where: BodyMetricWhereUniqueInput;
  data: BodyMetricUpdateWithoutUserDataInput;
}

export interface BodyMetricUpdateWithoutUserDataInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface BodyMetricUpsertWithWhereUniqueWithoutUserInput {
  where: BodyMetricWhereUniqueInput;
  update: BodyMetricUpdateWithoutUserDataInput;
  create: BodyMetricCreateWithoutUserInput;
}

export interface BodyMetricScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weight?: Float;
  weight_not?: Float;
  weight_in?: Float[] | Float;
  weight_not_in?: Float[] | Float;
  weight_lt?: Float;
  weight_lte?: Float;
  weight_gt?: Float;
  weight_gte?: Float;
  height?: Float;
  height_not?: Float;
  height_in?: Float[] | Float;
  height_not_in?: Float[] | Float;
  height_lt?: Float;
  height_lte?: Float;
  height_gt?: Float;
  height_gte?: Float;
  bodyfat?: Float;
  bodyfat_not?: Float;
  bodyfat_in?: Float[] | Float;
  bodyfat_not_in?: Float[] | Float;
  bodyfat_lt?: Float;
  bodyfat_lte?: Float;
  bodyfat_gt?: Float;
  bodyfat_gte?: Float;
  AND?: BodyMetricScalarWhereInput[] | BodyMetricScalarWhereInput;
  OR?: BodyMetricScalarWhereInput[] | BodyMetricScalarWhereInput;
  NOT?: BodyMetricScalarWhereInput[] | BodyMetricScalarWhereInput;
}

export interface BodyMetricUpdateManyWithWhereNestedInput {
  where: BodyMetricScalarWhereInput;
  data: BodyMetricUpdateManyDataInput;
}

export interface BodyMetricUpdateManyDataInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface BodyMeasurementUpdateManyWithoutUserInput {
  create?:
    | BodyMeasurementCreateWithoutUserInput[]
    | BodyMeasurementCreateWithoutUserInput;
  delete?: BodyMeasurementWhereUniqueInput[] | BodyMeasurementWhereUniqueInput;
  connect?: BodyMeasurementWhereUniqueInput[] | BodyMeasurementWhereUniqueInput;
  set?: BodyMeasurementWhereUniqueInput[] | BodyMeasurementWhereUniqueInput;
  disconnect?:
    | BodyMeasurementWhereUniqueInput[]
    | BodyMeasurementWhereUniqueInput;
  update?:
    | BodyMeasurementUpdateWithWhereUniqueWithoutUserInput[]
    | BodyMeasurementUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | BodyMeasurementUpsertWithWhereUniqueWithoutUserInput[]
    | BodyMeasurementUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | BodyMeasurementScalarWhereInput[]
    | BodyMeasurementScalarWhereInput;
  updateMany?:
    | BodyMeasurementUpdateManyWithWhereNestedInput[]
    | BodyMeasurementUpdateManyWithWhereNestedInput;
}

export interface BodyMeasurementUpdateWithWhereUniqueWithoutUserInput {
  where: BodyMeasurementWhereUniqueInput;
  data: BodyMeasurementUpdateWithoutUserDataInput;
}

export interface BodyMeasurementUpdateWithoutUserDataInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface BodyMeasurementUpsertWithWhereUniqueWithoutUserInput {
  where: BodyMeasurementWhereUniqueInput;
  update: BodyMeasurementUpdateWithoutUserDataInput;
  create: BodyMeasurementCreateWithoutUserInput;
}

export interface BodyMeasurementScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  hips?: Float;
  hips_not?: Float;
  hips_in?: Float[] | Float;
  hips_not_in?: Float[] | Float;
  hips_lt?: Float;
  hips_lte?: Float;
  hips_gt?: Float;
  hips_gte?: Float;
  waist?: Float;
  waist_not?: Float;
  waist_in?: Float[] | Float;
  waist_not_in?: Float[] | Float;
  waist_lt?: Float;
  waist_lte?: Float;
  waist_gt?: Float;
  waist_gte?: Float;
  rightArm?: Float;
  rightArm_not?: Float;
  rightArm_in?: Float[] | Float;
  rightArm_not_in?: Float[] | Float;
  rightArm_lt?: Float;
  rightArm_lte?: Float;
  rightArm_gt?: Float;
  rightArm_gte?: Float;
  leftArm?: Float;
  leftArm_not?: Float;
  leftArm_in?: Float[] | Float;
  leftArm_not_in?: Float[] | Float;
  leftArm_lt?: Float;
  leftArm_lte?: Float;
  leftArm_gt?: Float;
  leftArm_gte?: Float;
  rightLeg?: Float;
  rightLeg_not?: Float;
  rightLeg_in?: Float[] | Float;
  rightLeg_not_in?: Float[] | Float;
  rightLeg_lt?: Float;
  rightLeg_lte?: Float;
  rightLeg_gt?: Float;
  rightLeg_gte?: Float;
  leftLeg?: Float;
  leftLeg_not?: Float;
  leftLeg_in?: Float[] | Float;
  leftLeg_not_in?: Float[] | Float;
  leftLeg_lt?: Float;
  leftLeg_lte?: Float;
  leftLeg_gt?: Float;
  leftLeg_gte?: Float;
  AND?: BodyMeasurementScalarWhereInput[] | BodyMeasurementScalarWhereInput;
  OR?: BodyMeasurementScalarWhereInput[] | BodyMeasurementScalarWhereInput;
  NOT?: BodyMeasurementScalarWhereInput[] | BodyMeasurementScalarWhereInput;
}

export interface BodyMeasurementUpdateManyWithWhereNestedInput {
  where: BodyMeasurementScalarWhereInput;
  data: BodyMeasurementUpdateManyDataInput;
}

export interface BodyMeasurementUpdateManyDataInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface UserUpsertWithoutSchedulesInput {
  update: UserUpdateWithoutSchedulesDataInput;
  create: UserCreateWithoutSchedulesInput;
}

export interface ScheduleUpsertWithoutWorkoutsInput {
  update: ScheduleUpdateWithoutWorkoutsDataInput;
  create: ScheduleCreateWithoutWorkoutsInput;
}

export interface WorkoutUpsertNestedInput {
  update: WorkoutUpdateDataInput;
  create: WorkoutCreateInput;
}

export interface ScheduleUpdateOneInput {
  create?: ScheduleCreateInput;
  update?: ScheduleUpdateDataInput;
  upsert?: ScheduleUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleUpdateDataInput {
  time?: String;
  workouts?: WorkoutUpdateManyWithoutScheduleInput;
  completed?: Boolean;
  user?: UserUpdateOneRequiredWithoutSchedulesInput;
}

export interface ScheduleUpsertNestedInput {
  update: ScheduleUpdateDataInput;
  create: ScheduleCreateInput;
}

export interface NoteUpsertWithWhereUniqueWithoutCreatedByInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutCreatedByDataInput;
  create: NoteCreateWithoutCreatedByInput;
}

export interface NoteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  note?: String;
  note_not?: String;
  note_in?: String[] | String;
  note_not_in?: String[] | String;
  note_lt?: String;
  note_lte?: String;
  note_gt?: String;
  note_gte?: String;
  note_contains?: String;
  note_not_contains?: String;
  note_starts_with?: String;
  note_not_starts_with?: String;
  note_ends_with?: String;
  note_not_ends_with?: String;
  AND?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  OR?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  NOT?: NoteScalarWhereInput[] | NoteScalarWhereInput;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface NoteUpdateManyDataInput {
  note?: String;
}

export interface UserUpsertWithoutSavedWorkoutsInput {
  update: UserUpdateWithoutSavedWorkoutsDataInput;
  create: UserCreateWithoutSavedWorkoutsInput;
}

export interface SavedWorkoutUpsertWithoutExercisesInput {
  update: SavedWorkoutUpdateWithoutExercisesDataInput;
  create: SavedWorkoutCreateWithoutExercisesInput;
}

export interface ExerciseUpsertWithWhereUniqueWithoutWorkoutInput {
  where: ExerciseWhereUniqueInput;
  update: ExerciseUpdateWithoutWorkoutDataInput;
  create: ExerciseCreateWithoutWorkoutInput;
}

export interface WorkoutUpsertWithWhereUniqueWithoutScheduleInput {
  where: WorkoutWhereUniqueInput;
  update: WorkoutUpdateWithoutScheduleDataInput;
  create: WorkoutCreateWithoutScheduleInput;
}

export interface WorkoutScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: WorkoutScalarWhereInput[] | WorkoutScalarWhereInput;
  OR?: WorkoutScalarWhereInput[] | WorkoutScalarWhereInput;
  NOT?: WorkoutScalarWhereInput[] | WorkoutScalarWhereInput;
}

export interface WorkoutUpdateManyWithWhereNestedInput {
  where: WorkoutScalarWhereInput;
  data: WorkoutUpdateManyDataInput;
}

export interface WorkoutUpdateManyDataInput {
  name?: String;
  completed?: Boolean;
}

export interface ScheduleUpsertWithWhereUniqueWithoutUserInput {
  where: ScheduleWhereUniqueInput;
  update: ScheduleUpdateWithoutUserDataInput;
  create: ScheduleCreateWithoutUserInput;
}

export interface ScheduleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: ScheduleScalarWhereInput[] | ScheduleScalarWhereInput;
  OR?: ScheduleScalarWhereInput[] | ScheduleScalarWhereInput;
  NOT?: ScheduleScalarWhereInput[] | ScheduleScalarWhereInput;
}

export interface ScheduleUpdateManyWithWhereNestedInput {
  where: ScheduleScalarWhereInput;
  data: ScheduleUpdateManyDataInput;
}

export interface ScheduleUpdateManyDataInput {
  time?: String;
  completed?: Boolean;
}

export interface UserUpsertWithoutBodyMeasurementsInput {
  update: UserUpdateWithoutBodyMeasurementsDataInput;
  create: UserCreateWithoutBodyMeasurementsInput;
}

export interface BodyMeasurementUpdateManyMutationInput {
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface BodyMetricCreateInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
  user: UserCreateOneWithoutBodyMetricsInput;
}

export interface UserCreateOneWithoutBodyMetricsInput {
  create?: UserCreateWithoutBodyMetricsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutBodyMetricsInput {
  schedules?: ScheduleCreateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutCreateManyWithoutUserInput;
  notes?: NoteCreateManyWithoutCreatedByInput;
  bodyMeasurements?: BodyMeasurementCreateManyWithoutUserInput;
  authId: String;
}

export interface BodyMetricUpdateInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
  user?: UserUpdateOneRequiredWithoutBodyMetricsInput;
}

export interface UserUpdateOneRequiredWithoutBodyMetricsInput {
  create?: UserCreateWithoutBodyMetricsInput;
  update?: UserUpdateWithoutBodyMetricsDataInput;
  upsert?: UserUpsertWithoutBodyMetricsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutBodyMetricsDataInput {
  schedules?: ScheduleUpdateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutUpdateManyWithoutUserInput;
  notes?: NoteUpdateManyWithoutCreatedByInput;
  bodyMeasurements?: BodyMeasurementUpdateManyWithoutUserInput;
  authId?: String;
}

export interface UserUpsertWithoutBodyMetricsInput {
  update: UserUpdateWithoutBodyMetricsDataInput;
  create: UserCreateWithoutBodyMetricsInput;
}

export interface BodyMetricUpdateManyMutationInput {
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface ExerciseCreateInput {
  name: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  workout?: WorkoutCreateOneWithoutExercisesInput;
  savedWorkout?: SavedWorkoutCreateOneWithoutExercisesInput;
}

export interface ExerciseUpdateInput {
  name?: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
  workout?: WorkoutUpdateOneWithoutExercisesInput;
  savedWorkout?: SavedWorkoutUpdateOneWithoutExercisesInput;
}

export interface ExerciseUpdateManyMutationInput {
  name?: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
}

export interface NoteCreateInput {
  note: String;
  workout?: WorkoutCreateOneInput;
  createdBy: UserCreateOneWithoutNotesInput;
  schedule?: ScheduleCreateOneInput;
}

export interface UserCreateOneWithoutNotesInput {
  create?: UserCreateWithoutNotesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutNotesInput {
  schedules?: ScheduleCreateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutCreateManyWithoutUserInput;
  bodyMetrics?: BodyMetricCreateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementCreateManyWithoutUserInput;
  authId: String;
}

export interface NoteUpdateInput {
  note?: String;
  workout?: WorkoutUpdateOneInput;
  createdBy?: UserUpdateOneRequiredWithoutNotesInput;
  schedule?: ScheduleUpdateOneInput;
}

export interface UserUpdateOneRequiredWithoutNotesInput {
  create?: UserCreateWithoutNotesInput;
  update?: UserUpdateWithoutNotesDataInput;
  upsert?: UserUpsertWithoutNotesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutNotesDataInput {
  schedules?: ScheduleUpdateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutUpdateManyWithoutUserInput;
  bodyMetrics?: BodyMetricUpdateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementUpdateManyWithoutUserInput;
  authId?: String;
}

export interface UserUpsertWithoutNotesInput {
  update: UserUpdateWithoutNotesDataInput;
  create: UserCreateWithoutNotesInput;
}

export interface NoteUpdateManyMutationInput {
  note?: String;
}

export interface SavedWorkoutCreateInput {
  name: String;
  exercises?: ExerciseCreateManyWithoutSavedWorkoutInput;
  user: UserCreateOneWithoutSavedWorkoutsInput;
}

export interface SavedWorkoutUpdateInput {
  name?: String;
  exercises?: ExerciseUpdateManyWithoutSavedWorkoutInput;
  user?: UserUpdateOneRequiredWithoutSavedWorkoutsInput;
}

export interface SavedWorkoutUpdateManyMutationInput {
  name?: String;
}

export interface ScheduleUpdateInput {
  time?: String;
  workouts?: WorkoutUpdateManyWithoutScheduleInput;
  completed?: Boolean;
  user?: UserUpdateOneRequiredWithoutSchedulesInput;
}

export interface ScheduleUpdateManyMutationInput {
  time?: String;
  completed?: Boolean;
}

export interface UserCreateInput {
  schedules?: ScheduleCreateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutCreateManyWithoutUserInput;
  notes?: NoteCreateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricCreateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementCreateManyWithoutUserInput;
  authId: String;
}

export interface UserUpdateInput {
  schedules?: ScheduleUpdateManyWithoutUserInput;
  savedWorkouts?: SavedWorkoutUpdateManyWithoutUserInput;
  notes?: NoteUpdateManyWithoutCreatedByInput;
  bodyMetrics?: BodyMetricUpdateManyWithoutUserInput;
  bodyMeasurements?: BodyMeasurementUpdateManyWithoutUserInput;
  authId?: String;
}

export interface UserUpdateManyMutationInput {
  authId?: String;
}

export interface WorkoutUpdateInput {
  name?: String;
  exercises?: ExerciseUpdateManyWithoutWorkoutInput;
  completed?: Boolean;
  schedule?: ScheduleUpdateOneRequiredWithoutWorkoutsInput;
}

export interface WorkoutUpdateManyMutationInput {
  name?: String;
  completed?: Boolean;
}

export interface BodyMeasurementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BodyMeasurementWhereInput;
  AND?:
    | BodyMeasurementSubscriptionWhereInput[]
    | BodyMeasurementSubscriptionWhereInput;
  OR?:
    | BodyMeasurementSubscriptionWhereInput[]
    | BodyMeasurementSubscriptionWhereInput;
  NOT?:
    | BodyMeasurementSubscriptionWhereInput[]
    | BodyMeasurementSubscriptionWhereInput;
}

export interface BodyMetricSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BodyMetricWhereInput;
  AND?: BodyMetricSubscriptionWhereInput[] | BodyMetricSubscriptionWhereInput;
  OR?: BodyMetricSubscriptionWhereInput[] | BodyMetricSubscriptionWhereInput;
  NOT?: BodyMetricSubscriptionWhereInput[] | BodyMetricSubscriptionWhereInput;
}

export interface ExerciseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExerciseWhereInput;
  AND?: ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput;
  OR?: ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput;
  NOT?: ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NoteWhereInput;
  AND?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
  OR?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
  NOT?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
}

export interface SavedWorkoutSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SavedWorkoutWhereInput;
  AND?:
    | SavedWorkoutSubscriptionWhereInput[]
    | SavedWorkoutSubscriptionWhereInput;
  OR?:
    | SavedWorkoutSubscriptionWhereInput[]
    | SavedWorkoutSubscriptionWhereInput;
  NOT?:
    | SavedWorkoutSubscriptionWhereInput[]
    | SavedWorkoutSubscriptionWhereInput;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleWhereInput;
  AND?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  OR?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  NOT?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface WorkoutSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkoutWhereInput;
  AND?: WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput;
  OR?: WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput;
  NOT?: WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BodyMeasurement {
  id: ID_Output;
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface BodyMeasurementPromise
  extends Promise<BodyMeasurement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hips: () => Promise<Float>;
  waist: () => Promise<Float>;
  rightArm: () => Promise<Float>;
  leftArm: () => Promise<Float>;
  rightLeg: () => Promise<Float>;
  leftLeg: () => Promise<Float>;
  user: <T = UserPromise>() => T;
}

export interface BodyMeasurementSubscription
  extends Promise<AsyncIterator<BodyMeasurement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hips: () => Promise<AsyncIterator<Float>>;
  waist: () => Promise<AsyncIterator<Float>>;
  rightArm: () => Promise<AsyncIterator<Float>>;
  leftArm: () => Promise<AsyncIterator<Float>>;
  rightLeg: () => Promise<AsyncIterator<Float>>;
  leftLeg: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
}

export interface User {
  id: ID_Output;
  authId: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  schedules: <T = FragmentableArray<Schedule>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  savedWorkouts: <T = FragmentableArray<SavedWorkout>>(
    args?: {
      where?: SavedWorkoutWhereInput;
      orderBy?: SavedWorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notes: <T = FragmentableArray<Note>>(
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bodyMetrics: <T = FragmentableArray<BodyMetric>>(
    args?: {
      where?: BodyMetricWhereInput;
      orderBy?: BodyMetricOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bodyMeasurements: <T = FragmentableArray<BodyMeasurement>>(
    args?: {
      where?: BodyMeasurementWhereInput;
      orderBy?: BodyMeasurementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  authId: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  schedules: <T = Promise<AsyncIterator<ScheduleSubscription>>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  savedWorkouts: <T = Promise<AsyncIterator<SavedWorkoutSubscription>>>(
    args?: {
      where?: SavedWorkoutWhereInput;
      orderBy?: SavedWorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bodyMetrics: <T = Promise<AsyncIterator<BodyMetricSubscription>>>(
    args?: {
      where?: BodyMetricWhereInput;
      orderBy?: BodyMetricOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bodyMeasurements: <T = Promise<AsyncIterator<BodyMeasurementSubscription>>>(
    args?: {
      where?: BodyMeasurementWhereInput;
      orderBy?: BodyMeasurementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  authId: () => Promise<AsyncIterator<String>>;
}

export interface Schedule {
  id: ID_Output;
  time: String;
  completed?: Boolean;
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  id: () => Promise<ID_Output>;
  time: () => Promise<String>;
  workouts: <T = FragmentableArray<Workout>>(
    args?: {
      where?: WorkoutWhereInput;
      orderBy?: WorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  time: () => Promise<AsyncIterator<String>>;
  workouts: <T = Promise<AsyncIterator<WorkoutSubscription>>>(
    args?: {
      where?: WorkoutWhereInput;
      orderBy?: WorkoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface Workout {
  id: ID_Output;
  name: String;
  completed?: Boolean;
}

export interface WorkoutPromise extends Promise<Workout>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  exercises: <T = FragmentableArray<Exercise>>(
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<Boolean>;
  schedule: <T = SchedulePromise>() => T;
}

export interface WorkoutSubscription
  extends Promise<AsyncIterator<Workout>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  exercises: <T = Promise<AsyncIterator<ExerciseSubscription>>>(
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<AsyncIterator<Boolean>>;
  schedule: <T = ScheduleSubscription>() => T;
}

export interface Exercise {
  id: ID_Output;
  name: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
}

export interface ExercisePromise extends Promise<Exercise>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  sets: () => Promise<Int>;
  reps: () => Promise<Int>;
  intervals: () => Promise<Int>;
  duration: () => Promise<Float>;
  intensity: () => Promise<Int>;
  completed: () => Promise<Boolean>;
  workout: <T = WorkoutPromise>() => T;
  savedWorkout: <T = SavedWorkoutPromise>() => T;
}

export interface ExerciseSubscription
  extends Promise<AsyncIterator<Exercise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  sets: () => Promise<AsyncIterator<Int>>;
  reps: () => Promise<AsyncIterator<Int>>;
  intervals: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Float>>;
  intensity: () => Promise<AsyncIterator<Int>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
  workout: <T = WorkoutSubscription>() => T;
  savedWorkout: <T = SavedWorkoutSubscription>() => T;
}

export interface SavedWorkout {
  id: ID_Output;
  name: String;
}

export interface SavedWorkoutPromise
  extends Promise<SavedWorkout>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  exercises: <T = FragmentableArray<Exercise>>(
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserPromise>() => T;
}

export interface SavedWorkoutSubscription
  extends Promise<AsyncIterator<SavedWorkout>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  exercises: <T = Promise<AsyncIterator<ExerciseSubscription>>>(
    args?: {
      where?: ExerciseWhereInput;
      orderBy?: ExerciseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
}

export interface Note {
  id: ID_Output;
  note: String;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<ID_Output>;
  note: () => Promise<String>;
  workout: <T = WorkoutPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  schedule: <T = SchedulePromise>() => T;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  note: () => Promise<AsyncIterator<String>>;
  workout: <T = WorkoutSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  schedule: <T = ScheduleSubscription>() => T;
}

export interface BodyMetric {
  id: ID_Output;
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface BodyMetricPromise extends Promise<BodyMetric>, Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  bodyfat: () => Promise<Float>;
  user: <T = UserPromise>() => T;
}

export interface BodyMetricSubscription
  extends Promise<AsyncIterator<BodyMetric>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  bodyfat: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
}

export interface BodyMeasurementConnection {
  pageInfo: PageInfo;
  edges: BodyMeasurementEdge[];
}

export interface BodyMeasurementConnectionPromise
  extends Promise<BodyMeasurementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BodyMeasurementEdge>>() => T;
  aggregate: <T = AggregateBodyMeasurementPromise>() => T;
}

export interface BodyMeasurementConnectionSubscription
  extends Promise<AsyncIterator<BodyMeasurementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BodyMeasurementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBodyMeasurementSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BodyMeasurementEdge {
  node: BodyMeasurement;
  cursor: String;
}

export interface BodyMeasurementEdgePromise
  extends Promise<BodyMeasurementEdge>,
    Fragmentable {
  node: <T = BodyMeasurementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BodyMeasurementEdgeSubscription
  extends Promise<AsyncIterator<BodyMeasurementEdge>>,
    Fragmentable {
  node: <T = BodyMeasurementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBodyMeasurement {
  count: Int;
}

export interface AggregateBodyMeasurementPromise
  extends Promise<AggregateBodyMeasurement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBodyMeasurementSubscription
  extends Promise<AsyncIterator<AggregateBodyMeasurement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BodyMetricConnection {
  pageInfo: PageInfo;
  edges: BodyMetricEdge[];
}

export interface BodyMetricConnectionPromise
  extends Promise<BodyMetricConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BodyMetricEdge>>() => T;
  aggregate: <T = AggregateBodyMetricPromise>() => T;
}

export interface BodyMetricConnectionSubscription
  extends Promise<AsyncIterator<BodyMetricConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BodyMetricEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBodyMetricSubscription>() => T;
}

export interface BodyMetricEdge {
  node: BodyMetric;
  cursor: String;
}

export interface BodyMetricEdgePromise
  extends Promise<BodyMetricEdge>,
    Fragmentable {
  node: <T = BodyMetricPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BodyMetricEdgeSubscription
  extends Promise<AsyncIterator<BodyMetricEdge>>,
    Fragmentable {
  node: <T = BodyMetricSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBodyMetric {
  count: Int;
}

export interface AggregateBodyMetricPromise
  extends Promise<AggregateBodyMetric>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBodyMetricSubscription
  extends Promise<AsyncIterator<AggregateBodyMetric>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseConnection {
  pageInfo: PageInfo;
  edges: ExerciseEdge[];
}

export interface ExerciseConnectionPromise
  extends Promise<ExerciseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExerciseEdge>>() => T;
  aggregate: <T = AggregateExercisePromise>() => T;
}

export interface ExerciseConnectionSubscription
  extends Promise<AsyncIterator<ExerciseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExerciseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExerciseSubscription>() => T;
}

export interface ExerciseEdge {
  node: Exercise;
  cursor: String;
}

export interface ExerciseEdgePromise
  extends Promise<ExerciseEdge>,
    Fragmentable {
  node: <T = ExercisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExerciseEdgeSubscription
  extends Promise<AsyncIterator<ExerciseEdge>>,
    Fragmentable {
  node: <T = ExerciseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExercise {
  count: Int;
}

export interface AggregateExercisePromise
  extends Promise<AggregateExercise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExerciseSubscription
  extends Promise<AsyncIterator<AggregateExercise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavedWorkoutConnection {
  pageInfo: PageInfo;
  edges: SavedWorkoutEdge[];
}

export interface SavedWorkoutConnectionPromise
  extends Promise<SavedWorkoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SavedWorkoutEdge>>() => T;
  aggregate: <T = AggregateSavedWorkoutPromise>() => T;
}

export interface SavedWorkoutConnectionSubscription
  extends Promise<AsyncIterator<SavedWorkoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SavedWorkoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSavedWorkoutSubscription>() => T;
}

export interface SavedWorkoutEdge {
  node: SavedWorkout;
  cursor: String;
}

export interface SavedWorkoutEdgePromise
  extends Promise<SavedWorkoutEdge>,
    Fragmentable {
  node: <T = SavedWorkoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SavedWorkoutEdgeSubscription
  extends Promise<AsyncIterator<SavedWorkoutEdge>>,
    Fragmentable {
  node: <T = SavedWorkoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSavedWorkout {
  count: Int;
}

export interface AggregateSavedWorkoutPromise
  extends Promise<AggregateSavedWorkout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSavedWorkoutSubscription
  extends Promise<AsyncIterator<AggregateSavedWorkout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleConnection {
  pageInfo: PageInfo;
  edges: ScheduleEdge[];
}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedulePromise>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface ScheduleEdge {
  node: Schedule;
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = SchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkoutConnection {
  pageInfo: PageInfo;
  edges: WorkoutEdge[];
}

export interface WorkoutConnectionPromise
  extends Promise<WorkoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkoutEdge>>() => T;
  aggregate: <T = AggregateWorkoutPromise>() => T;
}

export interface WorkoutConnectionSubscription
  extends Promise<AsyncIterator<WorkoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkoutSubscription>() => T;
}

export interface WorkoutEdge {
  node: Workout;
  cursor: String;
}

export interface WorkoutEdgePromise extends Promise<WorkoutEdge>, Fragmentable {
  node: <T = WorkoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkoutEdgeSubscription
  extends Promise<AsyncIterator<WorkoutEdge>>,
    Fragmentable {
  node: <T = WorkoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkout {
  count: Int;
}

export interface AggregateWorkoutPromise
  extends Promise<AggregateWorkout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkoutSubscription
  extends Promise<AsyncIterator<AggregateWorkout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BodyMeasurementSubscriptionPayload {
  mutation: MutationType;
  node: BodyMeasurement;
  updatedFields: String[];
  previousValues: BodyMeasurementPreviousValues;
}

export interface BodyMeasurementSubscriptionPayloadPromise
  extends Promise<BodyMeasurementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BodyMeasurementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BodyMeasurementPreviousValuesPromise>() => T;
}

export interface BodyMeasurementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BodyMeasurementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BodyMeasurementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BodyMeasurementPreviousValuesSubscription>() => T;
}

export interface BodyMeasurementPreviousValues {
  id: ID_Output;
  hips?: Float;
  waist?: Float;
  rightArm?: Float;
  leftArm?: Float;
  rightLeg?: Float;
  leftLeg?: Float;
}

export interface BodyMeasurementPreviousValuesPromise
  extends Promise<BodyMeasurementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hips: () => Promise<Float>;
  waist: () => Promise<Float>;
  rightArm: () => Promise<Float>;
  leftArm: () => Promise<Float>;
  rightLeg: () => Promise<Float>;
  leftLeg: () => Promise<Float>;
}

export interface BodyMeasurementPreviousValuesSubscription
  extends Promise<AsyncIterator<BodyMeasurementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hips: () => Promise<AsyncIterator<Float>>;
  waist: () => Promise<AsyncIterator<Float>>;
  rightArm: () => Promise<AsyncIterator<Float>>;
  leftArm: () => Promise<AsyncIterator<Float>>;
  rightLeg: () => Promise<AsyncIterator<Float>>;
  leftLeg: () => Promise<AsyncIterator<Float>>;
}

export interface BodyMetricSubscriptionPayload {
  mutation: MutationType;
  node: BodyMetric;
  updatedFields: String[];
  previousValues: BodyMetricPreviousValues;
}

export interface BodyMetricSubscriptionPayloadPromise
  extends Promise<BodyMetricSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BodyMetricPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BodyMetricPreviousValuesPromise>() => T;
}

export interface BodyMetricSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BodyMetricSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BodyMetricSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BodyMetricPreviousValuesSubscription>() => T;
}

export interface BodyMetricPreviousValues {
  id: ID_Output;
  weight?: Float;
  height?: Float;
  bodyfat?: Float;
}

export interface BodyMetricPreviousValuesPromise
  extends Promise<BodyMetricPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  bodyfat: () => Promise<Float>;
}

export interface BodyMetricPreviousValuesSubscription
  extends Promise<AsyncIterator<BodyMetricPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  bodyfat: () => Promise<AsyncIterator<Float>>;
}

export interface ExerciseSubscriptionPayload {
  mutation: MutationType;
  node: Exercise;
  updatedFields: String[];
  previousValues: ExercisePreviousValues;
}

export interface ExerciseSubscriptionPayloadPromise
  extends Promise<ExerciseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExercisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExercisePreviousValuesPromise>() => T;
}

export interface ExerciseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExerciseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExerciseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExercisePreviousValuesSubscription>() => T;
}

export interface ExercisePreviousValues {
  id: ID_Output;
  name: String;
  sets?: Int;
  reps?: Int;
  intervals?: Int;
  duration?: Float;
  intensity?: Int;
  completed?: Boolean;
}

export interface ExercisePreviousValuesPromise
  extends Promise<ExercisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  sets: () => Promise<Int>;
  reps: () => Promise<Int>;
  intervals: () => Promise<Int>;
  duration: () => Promise<Float>;
  intensity: () => Promise<Int>;
  completed: () => Promise<Boolean>;
}

export interface ExercisePreviousValuesSubscription
  extends Promise<AsyncIterator<ExercisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  sets: () => Promise<AsyncIterator<Int>>;
  reps: () => Promise<AsyncIterator<Int>>;
  intervals: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Float>>;
  intensity: () => Promise<AsyncIterator<Int>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface NotePreviousValues {
  id: ID_Output;
  note: String;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  note: () => Promise<String>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  note: () => Promise<AsyncIterator<String>>;
}

export interface SavedWorkoutSubscriptionPayload {
  mutation: MutationType;
  node: SavedWorkout;
  updatedFields: String[];
  previousValues: SavedWorkoutPreviousValues;
}

export interface SavedWorkoutSubscriptionPayloadPromise
  extends Promise<SavedWorkoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SavedWorkoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SavedWorkoutPreviousValuesPromise>() => T;
}

export interface SavedWorkoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SavedWorkoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SavedWorkoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SavedWorkoutPreviousValuesSubscription>() => T;
}

export interface SavedWorkoutPreviousValues {
  id: ID_Output;
  name: String;
}

export interface SavedWorkoutPreviousValuesPromise
  extends Promise<SavedWorkoutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SavedWorkoutPreviousValuesSubscription
  extends Promise<AsyncIterator<SavedWorkoutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  node: Schedule;
  updatedFields: String[];
  previousValues: SchedulePreviousValues;
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValuesPromise>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface SchedulePreviousValues {
  id: ID_Output;
  time: String;
  completed?: Boolean;
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  time: () => Promise<String>;
  completed: () => Promise<Boolean>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  time: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  authId: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  authId: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  authId: () => Promise<AsyncIterator<String>>;
}

export interface WorkoutSubscriptionPayload {
  mutation: MutationType;
  node: Workout;
  updatedFields: String[];
  previousValues: WorkoutPreviousValues;
}

export interface WorkoutSubscriptionPayloadPromise
  extends Promise<WorkoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkoutPreviousValuesPromise>() => T;
}

export interface WorkoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkoutPreviousValuesSubscription>() => T;
}

export interface WorkoutPreviousValues {
  id: ID_Output;
  name: String;
  completed?: Boolean;
}

export interface WorkoutPreviousValuesPromise
  extends Promise<WorkoutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  completed: () => Promise<Boolean>;
}

export interface WorkoutPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkoutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Schedule",
    embedded: false
  },
  {
    name: "Workout",
    embedded: false
  },
  {
    name: "SavedWorkout",
    embedded: false
  },
  {
    name: "Exercise",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  },
  {
    name: "BodyMetric",
    embedded: false
  },
  {
    name: "BodyMeasurement",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
